---
layout: post
title:  "[리눅스마스터 1급] 이기적 이론서 16회차 정리 - 기출문제 1회 오답노트"
date:   2025-02-26 19:44:06 +0900
categories: 
            - linux
tags: [LinuxMaster]         
toc: false
related_posts:
    - study/_posts/linux/2025-02-20-리눅스마스터-13회차-DNS관련서비스.md
    - study/_posts/linux/2025-02-21-리눅스마스터-14회차-가상화관리,기타서비스.md
    - study/_posts/linux/2025-02-24-리눅스마스터-15회차-네트워크보안.md

---
* this unordered seed list will be replaced by the toc
{:toc}

# 이기적 최신 기출문제 01회 오답노트

## 1과목

### 1

- 리눅스는 대부분의 코드가 C언어로 작성되어 있어 다양한 CPU 아키텍처로의 **이식성**이 높다.
    - 리눅스는 플랫폼 종속적인 부분을 최소화하여 `어셈블리 언어`로 작성하고, 나머지 대부분을 `C 언어`로 구현해서 다양한 하드웨어에 쉽게 `이식`할 수 있다.
- 리눅스의 소스 코드 및 프로그램은 자유롭게 사용, 수정, 배포할 수 있는 **자유 소프트웨어**이다.

### 2

- 운영체제의 파일 시스템, 프로세스 관리, 메모리 관리, 입출력 기능 등 핵심 기능을 하나의 커널 공간에서 실행되는 단일 코드 베이스로 통합한 구조
    
    **모노리딕 커널**
    
    - 명령어의 입출력을 파일이나 다른 명령어로 전달한다.
        
        **리다이렉션**
        
    - 한 명령의 출력을 다른 명령의 입력으로 연결해 데이터 흐름을 처리한다.
        
        **파이프**
        
    - 운영체제의 핵심 기능을 최소화하고, 나머지 기능을 사용자 공간에서 실행하는 커널 구조
        
        **마이크로커널**
        

### 3

**어떤 계열의 리눅스 배포판인가?**

- CentOS, Fedora, Rocky Linux
    
    **Red Hat 계열**
    
- Ubuntu, Raspbian
    
    **Debian 계열**
    
- 하모니카, 구름OS
    
    **Ubuntu 기반으로 한국에서 개발됨**
    
- openSuse
    
    **SUSE 계열**
    

### 4

**LVM(Logical) Volume Manager**

- `물리적 볼륨을 논리적 볼륨으로 결합`하여 저장 공간을 유연하게 관리
- 디스크를 추가하지 않고 기존 볼륨의 크기를 `동적으로 확장, 축소` 가능
- 디스크 `스냅샷` 기능을 제공하여 특정 시점의 데이터 백업 가능
- **캐싱 기능**을 기본적으로 제공하지 **않음**
- 파일 시스템의 성능 개선보다는 **디스크 공간 관리와 관련된 유연성 제공**이 주 목적

### 5

- 리눅스 부팅 시 가장 먼저 실행되어 다른 모든 프로세스의 부모 역할을 하는 프로세스
    
    **init**
    
- 현대 리눅스 배포판에서 위의 명령어를 대체하며, 병렬 처리를 통해 더 빠른 부팅 속도를 제공하는 시스템 관리 도구
    
    **systemd**
    

### 6

**systemd에서 제공하는 Unit 유형**

- Service Unit
    - [오답] ****~~Process Unit~~ → Service Unit에 의해 간접적으로 관리됨
- Target Unit
- Device Unit
- Mount Unit
- Path Unit
- Socket Unit
- Timer Unit

### 7

**GRUB2 패스워드를 잃어버렸을 때의 대처 방법**

- root 비밀번호를 알고 있다면 `GRUB 설정을 편집`하여 복구 가능
- 부팅 시 GRUB 메뉴에서 `e` 키를 눌러 GRUB 설정을 편집한 후, 패스워드를 재설정
- GRUB 메뉴 접근이 불가하다면 (root 비밀번호를 잃어버렸다면) `복구 디스크`를 통해 부팅한 후 GRUB 설정 편집
- [오답] ~~BIOS 설정을 초기화하고 리눅스 초기화~~

### 8

**systemd를 사용한 전원 관리**

- 시스템 종료
    
    **systemctl halt**
    
- 시스템 재부팅
    
    **systemctl reboot**
    
- 시스템 절전모드
    
    systemctl hibernate
    
- [오답] ~~systemctl halt~~ → 특정 서비스나 시스템의 현재 상태 확인

### 9

- 실제 파일과 디렉터리의 데이터 위치를 알고 있는 자료구조로, 파일 권한, 하드링크 수, 소유자 id, 파일 크기, 마지막 접근 시간 등의 정보를 담고 있다.
    
    **아이노드**
    
    [오답]
    
    - 대형 파일 시스템을 더 작은 그룹으로 나누어 관리하기 위한 구조
        
        **블록 그룹** 
        
        - 각 그룹은 슈퍼 블록, 그룹 디스크립터 테이블, 데이터 블록, 아이노드 테이블 등을 포함
    - 디스크의 첫 번째 섹터로, 운영체제를 부팅하기 위한 정보를 포함
        
        **부트 섹터**
        
    - 파일 시스템의 크기, 빈 블록 수, 사용된 블록 수 등의 블록 그룹의 전체적인 정보를 저장
        
        **슈퍼 블록**
        

### 10

**X 윈도우**

- 키보드, 마우스, 화면과 같은 실제 장치와 `직접 통신을 수행`하고 관리
- **`X 클라이언트`** : `Xlib`을 사용하여 작성된 응용 프로그램
- X 서버와 X 클라이언트가 정보를 주고 받기 위해 **`X 프로토콜`**을 사용
- [오답] 서버 클라이언트 구조를 기반으로 X 프로토콜을 통해 ~~플랫폼 종속적~~ GUI 환경 구현 → **플랫폼 독립적인 GUI 환경 제공**

### 11

```bash
[ihd@www ~] (    ) HOME
/home/ihd
```

- 정답
    
    **printenv** : 환경변수 값 확인 ****
    
    [오답]
    
    - `echo` : 환경 변수 내용 조회할 수 있지만, `$` 를 변수 이름 앞에 붙여야 한다.
        
        ```bash
        $ echo $HOME
        ```
        

### 12

**셸의 메타문자**

- 리다이렉션을 통해 출력을 파일에 추가
    
    **>>**
    
- 와일드카드로, 파일 이름 패턴에서 모든 문자를 의미
    
    *****
    
- 논리 OR 연산자, 첫 번째 명령 실패시 두 번째 명령을 실행
    
    **||**
    

### 13

**kill 명령어**

- `SIGKILL` 과 같은 특정 시그널을 다른 프로세스에 전달 가능
- root 사용자만이 다른 사용자가 생성한 프로세스를 kill 가능
- `-l` 옵션을 통해 리눅스가 제공하는 시그널 목록 확인
- [오답] ~~root 사용자만 사용자가 직접 생성한 프로세스를 kill 가능~~ → 사용자는 자신이 생성한 프로세스를 **직접 kill 가능**

### 14

**좀비 프로세스**

- **실행이 완료**되었지만, 부모 프로세스가 종료 상태를 **수거하지 않아** 남아있는 프로세스
- **메모리와 CPU 자원을 계속해서 소모하지 않지만** 프로세스 테이블의 **엔트리를 차지**
- 부모 프로세스가 종료될 때 **자동으로 사라지지 않음**
- `kill` 명령어로 **직접 종료할 수 없음**

### 15

**셸 스크립트의 위치 매개변수**

- **`$0`** : 현재 실행 중인 스크립트의 이름
- `$1`, `$2` 등 : 스크립트 실행 시 전달된 인자(argument)
- `$#` : 스크립트에 전달된 인자의 총 개수
- `$*` : 인자 전체를 **하나의 문자열(String)**로 처리, 개별 인자 사이에 **구분자를 추가하지 않고** 출력
- `$@` : 환경변수 $IFS 설정된 구분자를 통해 **인자를 각각 나누어** 출력

### 16

**TCP/IP의 4가지 계층**

- 데이터가 물리적으로 네트워크로 전송됨
    
    **네트워크 엑세스 계층**
    
- 네트워크 간 패킷의 라우팅을 담당
    
    **인터넷 계층**
    
- 데이터의 신뢰성 있는 전송을 제공
    
    **전송 계층**
    
- 어플리케이션이 사용자와 상호 작용
    
    **응용 계층**
    

### 17

**특수 목적 IP 주소**

- `127.0.0.1` : 루프백 주소로, 자신의 컴퓨터를 가리키며 네트워크 인터페이스를 거치지 않고 내부에서 통신할 때 사용
- `169.254.0.0 ~ 169.254.255.255` : APIPA 범위로, DHCP 서버로부터 IP 주소를 받지 못할 경우 자동으로 할당되는 IP 주소 범위
- `255.255.255.255` : 브로드캐스트 주소, 네트워크의 모든 호스트에게 데이터를 전송할 때 사용
- `192.168.0.0 ~ 192.168.255.255` : 사설 IP 주소 범위, **인터넷에서 직접 사용되지 않고 내부 네트워크 구축** 시 사용

### 18

**IP가 192.168.123.132/26**

- 서브넷 마스크
    
    **255.255.255.192**
    
- 네트워크 주소
    
    **192.168.123.128**
    
- 실제 사용 가능한 호스트의 수
    
    **62**

> **계산 방법**
> 1. 서브넷 마스크 구하기
>   - CIDR 표기법이 /26이면 앞에서 26비트가 네트워크, 남은 32 - 26 = 6비트가 호스트 부분이다.
>   - 이진수로 표현 시 11111111.11111111.11111111.11000000
>   - 10진수로 변환하면 255.255.255.192 (서브넷 마스크)
> 2. 네트워크 주소 구하기
>   - IP 주소와 서브넷 마스크를 &&(AND) 연산을 적용한다.
>   - IP 주소의 24비트는 모두 1이므로, 마지막 8비트만 체크하면 된다.
>   - 10진수로 변환
> 3. 사용 가능한 호스트 수 구하기
>   - 호스트 부분이 6비트이므로 전체 IP 개수는 2^6 = 64개이다.
>   - 네트워크 주소(192.168.123.128)와 브로드캐스트 주소(192.168.123.191)는 사용불가이므로, 실제 사용한 호스트 수는 64 - 2 = 62개이다.

### 19

**ip 명령어**

- `ifconfig`  대체
- 네트워크 인터페이스에 IP를 할당하거나 제거 가능
- 네트워크 인터페이스를 활성화하거나 비활성화 가능
- [오답] ~~라우팅 정보 출력을 위해 ip 명령어 대신 route 명령어를 사용~~ → **ip route를 사용하여 라우팅 정보를 출력하거나 수정한다.**

### 20

- 네트워크 장애 분석을 위해 **`패킷`**이 어떤 경로로 전송되는지 **`추적`**하기 위한 명령어
    
    **traceroute**
    
    [오답]
    
    - 네트워크 연결, 라우팅 테이블, 인터페이스 통계 등을 보여주는 명령어
        
        **netstat**
        
    - 네트워크 인터페이스의 링크 상태를 확인하고 설정하는 도구
        
        **mii-tool**
        
    - `DNS` 서버에서 `호스트 이름을 IP 주소로 변환`하거나, `도메인 네임 정보`를 확인하는 명령어
        
        **dig**
        

## 2과목

### 21

**리눅스의 루트 계정 관리 방안**

- root 권한이 필요할 때, root 사용자로  로그인하는 것보다 `sudo` 명령어를 통해 임시로 권한을 획득하여 명령어 실행
- `/etc/passwd` 파일을 조사하여 `UID의 설정이 0`인 복수의 사용자가 있는지 점검
- 환경 변수 `TMOUT` 설정을 하여 자동 로그아웃이 되도록 함

### 22

**다음의 상황에서 사용자 계정 관리 방안**

운영팀에 새로 입사한 인턴은 3개월 간 근무를 한다. 인턴은 3개월간 시스템에 로그인하여 백업이 잘되는지 모니터링하는 업무를 수행한다.

- 사용자 계정 추가 시 **`useradd -e`** 명령어 사용
- 사용자 그룹은 운영팀으로 지정하고 적절한 권한 부여
- **`passwd -e`** 명령어를 사용하여 사용자가 다음 로그인시 패스워드를 직접 변경하도록 유도
- [오답] 3개월 이후 사용자 계정이 만료되도록 **`~~chage -e`** 명령어를 사용~~ → **chage -E를 사용해야 함**
    - **`chage - E`** : 계정 만료 후 패스워드가 비활성화 될 때까지 유예기간 설정

### 23

```bash
[root@www ~] #
root:$6$D2v/NwzEl6u9nOvL$0NSNUZZPaO
UXGD8Mmx6/6B1bcKuGRM:0:99999:7::
bin:*:19326:0:99999:7::
daemon:*:19326:0:99999:7::
adm:*:19326:0:99999:7::
lp:*:19326:0:99999:7::
sync:*:19326:0:99999:7::
shutdown:*:19326:0:99999:7::
halt:*:19326:0:99999:7::
mail:*:19326:0:99999:7::

(중간 생략)

[root@www ~] #
```

- 위의 파일을 출력하는 명령어
    
    **cat /etc/shadow** 
    
    - `/etc/shadow` : 사용자의 암호화된 비밀번호 및 패스워드 정책 관련 정보를 저장하는 파일

### 24

- 사용자가 현재 세션에서 다른 그룹으로 전환하여 해당 그룹의 권한을 일시적으로 적용받도록 하는 명령어
    
    **newgrp**
    

### 25

**사용자와 그룹 관리 관련 명령어**

- 그룹 파일의 무결성 검사
    
    **grpck**
    
- 사용자가 시스템에 로그인할 때 사용
    
    **login**
    
- 다른 사용자 계정으로 전환
    
    **su**
    

**파일 관리 명령어**

- 파일 및 디렉터리의 목록과 정보 조회
    
    **ls**
    

### 26

```bash
$ ls -l /usr/sbin/adduser
lrwxrwxrwx. 1 root root 7 Oct 1 2022 /usr/sbin/adduser -> useradd
```

**위의 명령어의 실행결과**

- root 그룹의 사용자는 adduser 파일에 대한 읽기 권한 존재
- adduser 파일의 소유자는 root
- adduser 파일 실행 시 `useradd` 명령어가 실행됨
- [오답] 일반 사용자에게 useradd 파일을 실행할 권한 없음 → **useradd 파일의 권한은 추가로 확인해야 함**
    - `/user/sbin/adduser` 는 심볼릭 링크 파일로, 모든 사용자에게 읽기, 쓰기, 실행 권한을 부여하고 있음
    - 하지만, 해당 명령어가 가리키고 있는 실제 파일 `useradd` 의 실행 권한은 해당 출력 결과만으로 알 수 없음

> **실행 결과 분석**
> - 첫 번째 문자 `l` 은 심볼릭 링크(symbolic link) 를 의미함
>   - 즉, `/usr/sbin/adduser` 파일은 실제 실행 파일이 아니라 **다른 파일을 가리키는 링크**
>   - 여기서 `useradd` 라는 실제 파일을 가리키고 있음 → `/usr/sbin/adduser` 명령어를 실행하면 실제로는 `useradd` 명령어가 실행됨
> - `rwxrwxrwx` (모든 사용자 권한 `777` 부여)
>   - 소유자 (`root`) → `rwx` (읽기, 쓰기, 실행 권한)
>   - 소유 그룹 (`root`) → `rwx` (읽기, 쓰기, 실행 권한)
>   - 기타 사용자 (`others`) → `rwx` (읽기, 쓰기, 실행 권한)


