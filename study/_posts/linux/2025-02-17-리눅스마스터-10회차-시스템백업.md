---
layout: post
title:  "[리눅스마스터 1급] 이기적 이론서 10회차 정리 - 시스템 백업"
date:   2025-02-17 19:44:06 +0900
categories: 
            - linux
tags: [LinuxMaster]         
toc: true
related_posts:
    - study/_posts/linux/2025-02-14-리눅스마스터-8회차-주변장치.md
    - study/_posts/linux/2025-02-16-리눅스마스터-9회차-시스템분석.md
    - study/_posts/linux/2025-02-16-리눅스마스터-9회차-시스템보안및관리.md

---
* this unordered seed list will be replaced by the toc
{:toc}

> 🏁 **이기적 이론서 학습 범위**  
> - **PART 01** 리눅스 시스템 관리 
>      - **CHAPTER 03** 시스템 보안 및 관리 (**SECTION 03** 시스템 백업)


# 시스템 백업

## ☑️ 백업의 개요

### 백업의 필요성

- **비즈니스 연속성**
    - 업무 시스템이나 금융권 서비스, IT 서비스에 장애가 발생하더라도 복구하여 업무를 연속적으로 수행하는 것이 가능하려면 체계적 백업 전략 및 시스템 구축이 필수적이다.
- **데이터의 중요성**
    - 중요 실험의 결과물, 프로젝트 산출물, 회계 데이터, 고객 정보 등을 유실할 경우 복구하는 과정에서 많은 노력과 시간이 필요하다.
    - 가격으로 측정하기 어려운 데이터의 유실사고도 존재한다.
- **시스템 장애 발생 위험**
    - 사용자 실수, 관리자 실수, 하드웨어의 오류, 프로그램 오류, 해커의 공격, 도난, 자연재해 등 시스템의 장애를 초래하는 요인은 다양하다.

### 백업 전략 요건

- 다양한 데이터 손실 요인으로부터 복구가 가능해야 한다.
- 장애 발생 이전에 정상적으로 동작하던 상태로 복구가 가능해야 한다.
- 최소한의 노력, 비용, 데이터 손실만을 허용하는 백업 전략이어야 한다.
- 초기 백업 구축 이후에는 사람의 관리를 최소로 하는 자동화 또는 반 자동화된 백업 전략 및 시스템이어야 한다.

### 백업 전략 수립 시 고려사항

- **무엇을 백업할 것인가?**
    - 백업의 대상에 따라 백업 전략의 방향이 달라진다.
    - 백업할 데이터가 일반 문서, 데이터베이스, 사진, 동영상, 음악 파일, 일반적인 프로그램, 유틸리티 등 무엇인지 식별해야 한다.
    - 전체 시스템을 대상으로 백업이 필요할 수도 있다.
- **어디에 백업할 것인가?**
    - **로컬 백업**(local backup): 플로피 디스크, 테이프, 하드디스크(IDE, SCSI, S-ATA), 광자기 드라이브(CD, DVD, BLu-ray), USB 메모리, SSD 등 보조저장장치에 데이터를 저장하여 보관한다.
    - **오프사이트 백업**(offsite backup): 클라우드, 원격 시스템 등 지리적으로 떨어진 곳에 데이터를 보관한다.
    - 로컬 백업뿐 아니라 오프사이트 백업도 병행해야 한다.
- **언제 백업할 것인가?**
    - 백업 주기 결정
        - 운영체제의 경우, 운영체제 업그레이드 전까지는 파일 변경이 일어나지 않는다.
        - 애플리케이션의 경우, 실행 빈도에 따라 데이터 변경이 잦을 수 있다.
        - 라이프 사이클에 따라 사용자의 데이터가 달라질 것이다.
    - 백업 시작 시간 결정
        - 백업으로 인해 업무 방해나 사용자의 시스템 사용에 영향을 주면 안된다.
        - 대부분 자정 전후의 시간이 좋다.
- **적용할 백업 유형**
    - 전체 백업: 전체 시스템이나 전체 하드 디스크, 파티션 등 백업 대상을 모두 백업한다. 간단하고 확실하지만 변경되지 않은 데이터도 백업해서 데이터 공간 효율성이 떨어진다.
    - 증분 백업: 전체 백업 이후 변경된 데이터만 백업한다. 복구를 위해서는 전체 백업과 변경된 데이터 모두가 있어야 한다.
    - 차등 백업: 증분 백업과 동일하나, 증분 백업은 백업 시 별도의 백업 데이터가 생성되는 반면, 차등 백업은 지난 번 백업에 이번 변경 데이터를 누적하여 백업 데이터를 생성한다. 전체 백업 데이터와 가장 최근 백업 데이터만 있으면 전체를 복원할 수 있다.
- **백업의 압축과 암호화**
    - 압축 : 백업 데이터를 네트워크로 전송시 대역폭을 절약하거나 제한된 백업 매체의 용량을 최대한으로 이용하기 위해 고려한다.
    - 암호화 : 백업 데이터에 개인 사용자 정보나 민감 정보가 포함되어 고려한다.
- **백업 검증 방법**
    - 주기적으로 백업 데이터를 모의로 복원해보고 백업 유틸리티 등의 도움을 받아 백업 파일이 올바른지 확인하는 전략이 필요하다.
- **백업 유틸리티 및 서비스**
    - 오픈소스 백업 유틸리티 등을 이용해 자동화된 백업 서비스를 직접 구축하거나 신뢰할만한 백업 솔루션을 도입하는 전략을 고려한다.

## ☑️ 파일 백업

### tar

- 여러 파일을 모아 아카이브 파일을 생성하거나 아카이브 파일로부터 원래 파일들을 추출할 때 사용한다.
- 압축 기능도 지원하여 디스크 공간을 적게 차지한다.
- **전체 백업 (full backup)**
    - `-c` : 아카이브 생성, `-v` : 상세 정보 출력, `-f` : 아카이브 파일명 지정, `-p` : 접근 권한 유지
    - `-v`, `-p` 는 백업 필수 옵션은 아니다.
        
        ```bash
        # /path/to/dir의 모든 파일과 디렉터리를 묶어 archive.tar.gz를 생성
        $ tar -cvfp archive.tar /path/to/dir 
        ```
        
    - `-x` : 아카이브의 파일 추출, `-v` : 상세 정보 출력, `-f` : 아카이브 파일명
        
        ```bash
        $ tar -xvf archive.tar # archive.tar.gz을 현재 디렉터리에 복원
        ```
        
    - `tar` 로 백업 시 `-z` 나 `-j` 를 사용하여 `.gz` 나 `.bz2` 형식으로 **tar**를 압축할 수 있다.
        
        ```bash
        $ tar -cv**z**fp archive.tar.gz /path/to/dir
        OR
        $ tar -cv**j**fp archive.tar.gz /path/to/dir
        ```
        
    - `.gz` 나 `.bz2` 형식의 **tar** 파일을 복원할 때도 `-z`  나 `-j` 를 사용한다.
        
        ```bash
        $ tar -xv**z**f archive.tar.gz
        OR
        $ tar -xv**j**f archive.tar.bz2
        ```
        

- **증분 백업(incremental backup)**
    - `-g` ****를 사용하여 변경된 파일 및 디렉터리 정보를 스냅샷으로 보관한다.
    - 스냅샷 파일을 통해 **tar**를 만들 때마다 **변경된 사항만 tar로 묶어** 증분 백업을 수행한다.
    - 이전 백업 파일이 없는 최초 백업 파일을 **레벨 0(Level 0)** 백업이라고 한다.
        
        ```bash
        $ tar -g snapshot -cvfp archive-level0.tar /path/to/dir
        ```
        
    - 레벨1 백업 시 기존 생성된 레벨 0 백업의 스냅샷 파일을 통해 변경된 사항만 `archive-level1.tar` 백업 파일로 생성한다.
        
        ```bash
        $ tar -g snapshot -cvfp archive-level1.tar /path/to/dir
        ```
        
    - 레벨2 백업 시 기존 생성된 레벨 1 백업의 스냅샷 파일을 통해 변경된 사항만 `archive-level2.tar` 백업 파일을 생성한다.
        
        ```bash
        $ tar -g snapshot -dvfp archive-level2.tar /path/to/dir
        ```
        
    - 복원 시 백업한 순서대로 복원한다.
        
        ```bash
        $ tar -xvf archive-level0.tar -C /
        $ tar -xvf archive-level1.tar -C /
        $ tar -xvf archive-level2.tar -C /
        ```
        

### cpio

- 아카이브로 파일을 복사하거나 아카이브에서 파일을 추출할 때 사용한다.
- 바이너리, ASCII, HP-UX 바이너리, tar 형식을 지원한다.
- 자동으로 파일 형식과 시스템의 바이트 오더를 인지한다.
- **tar**와 유사한 기능이지만, **tar**는 많은 파일을 하나의 파일로 아카이브하기 위해 개발되었고, **cpio**는 하나의 디렉터리에서 다른 디렉터리로 파일을 복사하기 위해 개발되었다.
- 파일 시스템을 직접 접근하지 못하고 **표준입력**(STDIN)으로 입력 받으며, **증분 백업이 불가능**하다.
- 파일 복사 시 Copy-out 모드, Copy-in 모드, Copy-pass 모드가 있다.
    - 백업 시 Copy-out 모드, Copy-in 모드가 사용되고, 파일 복사 시 Copy-pass 모드가 사용된다.
- 형식
    - **Copy-out** 모드: `name-list`의 파일을 대상으로 아카이브를 생성한다.
    - **Copy-in** 모드: 아카이브에서 파일들을 추출한다.
    - **Copy-pass** 모드: `name-list`의 파일을 지정한 디렉터리로 복사한다.
- 옵션
    
    
    | 옵션 | 설명 |
    | --- | --- |
    | -o, —create | Copy-out 모드로 실행한다. |
    | -i, —extract | Copy-in 모드로 실행한다. |
    | -v, —verbose | 처리 중인 파일들의 목록을 출력한다. |
    | -c | - `-H newc` 명령어와 동일하며 **SVR4** 형식을 사용한다. <br> - 기존 **ASCII** 형식으로 지정하기 위해 `-H odc` 옵션을 사용한다. |
    | -d, —make-directions | 디렉터리를 생성한다. |
    | -t, —list | 입력으로 들어오는 목록을 출력한다. |
    | -F, —file | 표준 입력이나 표준 출력을 사용하지 않고 아카이브할 파일을 지정할 때 사용한다. |
    | -B | - `-B` 옵션을 사용하지 않으면 기본값인 512 바이트 단위로 파일 복사가 이루어진다. <br> - `-B` 옵션을 사용하면 그의 10배인 5120 바이트 단위로 복사가 이루어진다. |
    | -H, —formal | - 아카이브 할 포맷 형식을 지정한다. <br> - bin, odc, newc, crc, tar, ustar, hpbin, hpodc와 같은 포맷을 지정한다. |
    | -p, —pass-through | Copy-pass 모드로 실행한다. |
    | -0, —null | - 개행 문자가 아닌 null 문자로 종료되는 파일 목록을 읽는다. <br> - `find` 명령어는 null 문자로 종료되는 파일 목록을 출력한다. (이 옵션으로 파일을 받을 수 있다.) |

- **Copy-out 모드 예제**
    - 현재 경로의 모든 파일을 지정한 경로에 `backup.tar` 를 생성한다.
    - 파일 형식은 **tar**로, 리다이렉션 대신 `-F` 옵션을 사용하여 파일을 지정할 수 있다.
    
    ```bash
    $ ls | cpio -ov -H tar > home/test-account/backup.tar
    ```
    

- **Copy-in 모드 예제**
    
    ```bash
    $ cpio -iv < home/test-account/backup.cpio # backup.cpio에서 파일 추출
    
    $ cpio -ivt < home/test-account/backup.cpio # backup.cpio 내의 파일목록만 출력
    ```
    

- **Copy-pass 모드 예제**
    - `find` 로 찾은 파일 목록을 `new-dir` 에 복사한다.
    - `find` 의 `-depth` 는 디렉터리 내의 파일을 먼저 열거함, `-print0` 은 파일 목록을 null 종료 스트링으로 생성함
    - `cpio` 의 `—null` 은 null 종료 스트링의 목록을 받고, `-p` 는 Pass-through를 의미하고, `-d` 는 지정한 디렉터리로 복사한다.
    
    ```bash
    % find . -depth -print0 | cpio --null -pvd new-dir
    ```
    

## ☑️ 파일 시스템 및 디스크 백업

### dump

- 주로 **파티션 단위**로 **백업**할 때 사용한다.
- 형식
    
    ```bash
    dump [options][backup_device][backup_file_or_device]
    ```
    
- 옵션
    
    
    | 옵션 | 의미 |
    | --- | --- |
    | -0~9 | - 레벨을 지정한다. <br> - 0단계는 전체 백업, 1단계부터는 부분 백업이다. |
    | -f | 백업할 장치나 파일을 지정한다. |
    | -u | **dump** 완료 후 `/etc/dumpdates`라는 파일에 백업 정보를 기록한다. |

- 예제
    
    ```bash
    # /dev/hda7 전체를 백업하여 backup.dump를 생성
    # /etc/dumpdates에 백업 정보를 기록
    $ dump -0u -f backup.dump /dev/hda7 
    
    # /home 디렉터리 전체를 /dev/nst0이라는 장치에 백업
    $ dump -0f /dev/nst0 /home
    ```
    

### dd

- 지정한 장치를 지정한 형식으로 **변환**한다.
- **파티션이나 디스크 단위로 백업**하거나 CD 장치에서 ISO 이미지를 추출한다.
- 형식
    
    ```bash
    dd [option] ...
    ```
    
- 옵션
    
    
    | 옵션 | 설명 |
    | --- | --- |
    | if | 표준 입력 대신 지정한 파일이나 장치에서 읽는다. |
    | of | 표준 출력 대신 파일이나 장치로 쓴다. |
    | bs | - 블록을 읽거나 쓸 때 크기를 지정한다. - 바이트 단위이다. |

- 예제
    
    ```bash
    # /dev/sda1 장치를 /dev/sdb1 장치로 백업
    # 블록 크기는 1KB로 설정
    $ dd if=/dev/sda1 of=/dev/sdb1 bs=1k
    
    # /dev/sda 장치를 홈디렉터리의 disk.img 파일로 백업
    $ dd if=/dev/sda of=~/disk.img
    ```
    

### restore

- `dump` 명령으로 생성한 백업 파일을 **복원**할 때 사용한다.
- 형식
    
    ```bash
    restore [option] backup_name
    ```
    
- 옵션
    
    
    | 옵션 | 의미 |
    | --- | --- |
    | -i | 대화모드를 통해 복원할 파일을 지정한다. |
    | -t | - 복원할 파일을 지정한다. <br> - 테이프(/dev/st0)나 디스크(/dev/sda1) 같은 장치일 수 있다.  |
    | -r | - 파일 시스템을 복원한다. <br> - 파일 시스템은 미리 마운트 되어 있어야 한다. <br> - 보통은 0번 레벨의 전체 백업 이미지를 먼저 복원후 차례대로 1, 2, … 레벨의 증분 백업 이미지를 복원한다. |

- 예제
    
    ```bash
    $ restore -rf backup.dump # backup.dump 파일 복원
    
    $ restore -if backup.dump # 대화모드에서 backup.dump 파일 복원
    ```
    

## ☑️ 네트워크 백업

### rsync

- 네트워크로 연결된 리모트 컴퓨터의 파일들을 **동기화**하며 속도가 빠르다.
- 로컬 컴퓨터와 다른 원격 호스트, 원격 셸, rsync 데몬 간 **파일 복사**가 가능하다.
- 다양한 옵션을 제공하고 복사할 파일 목록을 지정하기 위한 유연한 방식을 제공한다.
- 전송할 파일과 원격지의 파일 간 차이점을 계산하여 전송하는 **델타 전송 알고리즘**을 적용해 네트워크 전송 속도를 비약적으로 향상시킨다.
- 반복되는 백업이나 미러링 등의 작업에 사용된다.
    
    
    | 기능 | 설명 |
    | --- | --- |
    | 다양한 속성 복사 | 파일 링크, 장치, 소유자, 그룹, 접근 권한 복사 지원 |
    | 제외 기능 | **GNU tar**과 유사하게 제외 기능 제공 |
    | 예외 기능 | **CVS**의 무시 기능과 동일한 **CVS** 파일 예외 기능 제공 |
    | 원격 셸 | **ssh**, **rsh**와 같은 원격 셸 지원 |
    | 사용자 권한 | 파일 복사할 때 루트 권한 불필요 |
    | 파이프라인 전송 | 지연시간 최소화를 위한 파이프 라인을 통한 파일 전송 |
    | 익명 및 사용자 인증 | 미러링에 최적화된 익명이나 사용자 인증 로그인이 가능한 **rsync** 데몬 제공 |

- 형식
    
    ```bash
    $ rsync [option] source destination
    ```
    
- 옵션
    
    
    | 옵션 | 설명 |
    | --- | --- |
    | -r, —recursive | 지정한 디렉터리의 모든 파일 및 하위 디렉터리까지 복사 |
    | l, —links | 파일에 대한 링크를 그대로 보존하여 복사 |
    | -p, —perms | 사용자 접근 권한을 그대로 보존하여 복사 |
    | -t, —times | 파일 수정 시간을 원격지에 전송해 파일 복사 시 보존되도록 함 |
    | -g, —group | 그룹 소유권을 그대로 보존하여 복사 |
    | -o, —owner | 루트 사용자만 가능하며 소유자를 그대로 보존하여 복사 |
    | -D, —devices, —specials | 원격지의 캐릭터와 블록 디바이스, 소켓, FIFO 등 장치, 특수 파일로 복사 가능하게 하며 루트 권한이 필요 |
    | -H, —hard-links | 하드 링크를 보존 |
    | -a, —archive | -`rlptgoD`와 동일한 옵션으로 여러 파일을 하나로 묶는 아카이브 모드로 동작 |
    | -v, —verbose | 파일 복사 과정에 대한 상세 정보 출력 |
    | -u, —update | 파일 수정 시간을 기준으로 판단하여 전송할 파일보다 최신 파일이 존재하는 경우 파일 전송을 건너 뜀 |
    | -z, —compress | 파일 전송 시 데이터를 압축해서 보내며, 네트워크 트래픽을 줄일 수 있어서 대역폭이 작은 네트워크에서 사용 시 유리 |
    | -b, —backup | 백업 시 동일한 파일이 존재하는 경우 이름을 변경하거나 특정 디렉터리로 옮기거나 삭제할 수 잇고, 기본은 ~를 붙여 이름을 변경 |
    | -e, —rsh | 원격지와 연결할 프로그램을 지정하고, 기본값은 **ssh**이며 이를 대체할 프로그램을 지정할 수 있음 |
    
- 예제
    
    ```bash
    # /home의 모든 파일을 속성까지 동일하게 원격지 francis 호스트의 public_html에 복사
    # 파일을 전송하는 사이, 압축해서 보냄
    $ rsync -avz /home francis:public_html/
    ```