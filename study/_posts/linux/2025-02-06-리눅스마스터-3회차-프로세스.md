---
layout: post
title:  "[리눅스마스터 1급] 이기적 이론서 3회차 정리 - 프로세스"
date:   2025-02-06 20:43:06 +0900
categories: 
            - linux
tags: [LinuxMaster]         
toc: true
related_posts:

---
* this unordered seed list will be replaced by the toc
{:toc}


> 🏁 **이기적 이론서 학습 범위**  
> - **PART 01** 리눅스 실무적 이해  
>    - **CHAPTER 02** 리눅스 시스템의 이해 (SECTION 05 프로세스)  

# 프로세스

## ☑️ 프로세스의 개요

### 프로세스의 개념

- 프로세스 : 디스크의 프로그램을 메모리에 적재하고 실행한 상태
- 프로세스 특징
    - 생성, 실행, 대기, 중지, 좀비, 종료 등의 라이프사이클을 갖는다.
    - 고유의 아이디인 PID를 갖는다.
    - 부모 프로세스와 자식 프로세스 간 관계를 맺으며 실행 우선순위와 프로세스의 상태를 갖는다.
    - 생성 시간, 시스템 실행 시간, 사용자 실행 시간 등의 시간 정보와 타이머를 가질 수 있다.
    - 사용 가상 메모리, 프로세스 컨텍스트, 파일 핸들 정보 등의 리소스를 갖는다.

### 프로세스 유형

- **최상위 프로세스**
    - 모든 프로세스의 부모 프로세스이다.
    - 리눅스 초기화를 위해 가장 먼저 실행하는 프로세스이며, 커널이 직접 시작한다.
    - **`PID`**는 항상 1이다.
        
        🧷 init 프로세스의 PID를 확인하려면? → **`pidof`**
        ex. `$ pidof systemd`
        
    - 레드햇 계열 6에서는 **`init`** 프로세스, 레드햇 계열 7 이후는 **`systemd`**가 최상위 프로세스이다.
- **부모 프로세스와 자식 프로세스**
    - 현재 실행 중인 프로세스 A (**부모 프로세스**)가 특정 실행 파일을 실행하여 프로세스 B (**자식 프로세스**)가 생성된다.
    - 자식 프로세스의 프로세스 ID는 **`PID`**, 부모 프로세스는 **`PPID`**
- **고아 프로세스와 좀비 프로세스**
    - 고아 프로세스 : 부모 프로세스가 강제 종료되었을 때 자식 프로세스는 고아 프로세스가 된다.
        - 고아 프로세스의 부모 프로세스는 **Init 프로세스**로 변경된다.
    - 좀비 프로세스 : 자식 프로세스 종료 시, 부모 프로세스가 **`wait()`** 시스템 콜 등으로 자식 프로세스의 종료 코드를 회수하지 못할 때 좀비 프로세스가 된다.
        - 종료 코드를 회수하면 프로세스 테이블에서도 **`PID`**가 삭제된다.
- **데몬**
    - 시스템 부팅 시 자동으로 시작되며, 백그라운드로 실행한다
    - 사용자가 직접 제어하지 않고 데몬의 관련 핸들러가 실행하는 방식이다.
    - 예시 : 작업 예약(cron), 파일 전송(ftpd), 프린터(lpd), 원격 접속(rlogind), 원격 명령(rshd), 텔넷(telned)

### 프로세스 식별자

- **PID** : 실행중인 프로세스를 구분하기 위해 시스템에서 유일한 아이디를 부여받은 것
- **PPID** : 생성된 프로세스의 부모 프로세스의 아이디
- **UID**, **GID** : 생성된 프로세스가 속한 사용자 또는 그룹 아이디

## ☑️ 프로세스 동작원리

### **프로세스 생성하기**

- **`exec()` 시스템 콜**
    - 현재 프로세스의 이미지를 새로운 프로세스의 이미지로 교체한다.
    - `$ exec ls -l`
- **`fork()`**
    - 프로세스가 **`fork()`** 를 호출하여 프로세스를 생성한다.
    - 호출한 프로세스를 복제하는 방식으로 새로운 프로세스를 생성한다.
    - 부모 프로세스의 메모리 락과 세마포어, 비동기 I/O 등은 상속되지 않는다.
- **`fork()` 와 `exec()` 를 통한 프로세스 생성 과정**
    1. **`fork()`** 를 통해 부모 프로세스를 복제하여 자식 프로세스가 생성된다.
    2. **`exec()`** 를 호출하여 자식프로세스의 프로그램으로 교체된다.
    3. 자식 프로세스가 **`exit()`** 를 호출하면 부모 프로세스는 wait() 시스템 콜을 통해 자식 프로세스의 종료 코드를 회수한다.
- **🧷** 프로세스의 구조를 확인하려면? → **`pstree`**
    
    `$ pstree`
    

### 프로세스 제어하기

- **포어그라운드 프로세스**
    - 사용자가 명령어나 프로그램을 실행하면 프로세스가 실행되는 사이에 셸은 블록이 되는 프로세스
    - 사용자의 입력을 받을 수 있고, 그 실행 결과를 터미널이나 그래픽 유저 인터페이스를 통해 확인할 수 있다.
- **백그라운드 프로세스**
    - 명령어의 수행결과를 받기까지 오래걸릴 때 백그라운드에서 프로세스를 실행할 수 있다.
    - 명령어 뒤에 **`‘&’`** 를 붙인다.
    - **`‘[’`** 와 **`‘]’`** 사이의 숫자는 작업 번호이며, 그 뒤 숫자는 **`PID`** 이다.
        
        ```bash
        $ ls ch*.ppt &
        [1] 12131
        ```
        
- **포어그라운드 프로세스와 백그라운드 프로세스 전환**
    - **`ctrl + z`** 를 입력하여 프로세스를 서스펜드한 후 **`bg`** 명령어로 백그라운드를 실행한다.
        
        ```bash
        $ [CTRL^Z]
        $ bg
        ```
        
    - 현재 실행중인 작업 정보를 보려면? → **`$ jobs`**
    - 백그라운드 프로세스를 다시 포어그라운드 프로세스로 돌리려면? → **`fg`**
        
        **`$ fg %1`** 
        
- **우선 순위의 설정**
    - **PR(Priority)** : 리눅스 커널에 의해 관리되고 설정된다.
        - 0~139의 값을 가진다.
        - 0~99는 실시간 태스크에, 100~139는 사용자에게 할당된다.
    - **NI(Nice)** : 사용자가 우선순위를 조절한다.
        - **`nice`** 명령어로 프로세스 시작 시 설정할 수 있다.
        - **`renice`** 명령어로 프로세스 실행 중 조절할 수 있다.
        - -20~19까지 할당되지만, 음수 값은 root 사용자만 설정할 수 있다.

### 프로세스 중지하기

- **`Ctrl + C`** : SIGINT 시그널을 해당 프로그램에 보내는 동작이다.
- **`kill`** 명령어
    - 인자에 프로세스의 PID를 지정하면 해당 프로세스를 종료한다.
    - 사용자는 사용자가 직접 생성한 프로세스만 **`kill`** 할 수 있다.
    - root 사용자는 시스템 프로세스를 **`kill`** 할 수 있고, 다른 사용자가 생성한 프로세스를 **`kill`** 할 수 있다.
    - 특정 시그널을 옵션으로 지정할 수 있다.
        
        **🧷 시그널** : 다른 프로세스에게 어떤 의미를 담은 신호를 주기 위한 방식
        
        예 : **`$ kill -SIGKILL 50123`**
        
        | 시그널 번호 | 시그널 이름 | 설명 |
        | --- | --- | --- |
        | 1 | SIGHUP | 터미널의 접속이 연결이 끊어질 때 보내는 시그널 |
        | 2 | SIGINT | **`Ctrl + C`** 를 통해 인터럽트 발생 시  |
        | 3 | SIGQUIT | **`Ctrl + \`** 입력 시 |
        | 9 | SIGKILL | 프로세스를 강제 종료 시 |
        | 15 | SIGTERM | 프로세를 정상 종료 시 |
        | 18 | SIGCONT | STOP 시그널을 통해 정지된 프로세스를 다시 재개할 때 |
        | 19 | SIGSTOP | 프로세스를 중지할 때 |
        | 20 | SIGTSTP | 프로세르를 대기하기 위해 **`Ctrl + Z`** 를 입력 시 |

### 프로세스 상태

- **프로세스 상태 코드**
    
    
    | 상태 코드 | 설명 |
    | --- | --- |
    | R | 프로세스가 현재 실행 중 |
    | D | I/O와 같은 인터럽트할 수 없는 슬립(sleep) 상태 |
    | S | 특정 이벤트가 시그널될 때까지 기다리기 위한 인터럽트가 가능한 슬립 상태 |
    | Z | 좀비 프로세스 |
    | T | 중지 상태 |
- **`ps`** , **`top`** 명령어로 프로세스의 상태를 확인할 수 있다.

### 프로세스 구조

- **PDB(Process Control Block)**
    - 프로세스를 실행하고 스케줄링하고 상태가 변경될 때마다 그 정보를 저장하기 위해 커널에서 **`PCB`** 로 프로세스에 대한 정보를 관리한다.

### 프로세스 간 통신

- **프로세스 간 통신(IPC, Inter-Process Communication)** : 서로 다른 프로세스들이 데이터를 주고 받거나 실행순서를 조정하는 등의 동기화 작업을 위해 시스템에서 제공하는 메커니즘
- **프로세스 간 통신의 유형**
    
    
    | 구분 | 설명 |
    | --- | --- |
    | 파이프 (Pipe) | 두 개의 프로세스 간 파이프를 연결하여 **단방향 통신**을 수행한다. 하나의 프로세스가 데이터를 파이프에 쓰면 다른 프로세스는 파이프로부터 데이터를 읽을 수 있다. |
    | 메시지 큐 (Message Queue) | **FIFO**(FIrst-In, First-Out)의 자료구조를 갖는 메모리 공간을 통해 여러 프로세스 간에 데이터를 주고받을 수 있다.  |
    | 공유 파일 (Shared File) | 여러 프로세스 간 동일 파일에 데이터를 읽기, 쓰기를 함으로서 프로세스 간 통신을 구현한다. |
    | 공유 메모리 (Shared Memory) | 여러 프로세스 간 **동시에** 데이터를 읽고 쓸 수 있는 메모리 영역을 공유한다. |
    | 세마포어 (Semaphore) | 다수의 프로세스 간 **실행 순서를 조정**하고 **임계영역을 보호**하기 위한 동기화 객체 |
    | 소켓 (Socket)  | 네트워크 연결의 양 끝단을 소켓이라고 한다. 소켓은 IP주소와 포트번호 등의 속성을 가진다. 통신 채널을 형상하여 프로세스 간 통신도 가능하다. |
    | 시그널 (Signal) | 특정 이벤트나 상태를 다른 프로세스에 전달하는 비동기적 통신 방법 |
    - **`lsipc`** , **`ipcs`** 명령어로 관련 정보를 조회할 수 있다.
- 프로세스 테이블
    - 시스템에서 실행중인 모든 프로세스를 관리한다.
    - 현재 실행 중인 프로세스의 **`PID`** 와 프로세스의 정보를 담고 있는 **`PCB`** 를 담고 있다.
    - 프로세스 종료 시 프로세스 테이블에서도 삭제된다.

## ☑️ 데몬

### 데몬 실행 방식

- **`standalone`** 방식
    - 사용자의 요청 없이 시스템 시작 시 자동으로 시작해 백그라운드에서 대기한다.
    - 클라이언트 요청 시 즉각적으로 서비스를 제공한다.
    - 사용하지 않을 때에도 메모리를 점유하고 있어서 비효율적이다.
    - 서비스의 요청이 빈번할 경우 적합하다.
    - **`/etc/systemd/system`** 에 **`.service`** 로 끝나는 데몬 스크립트가 위치한다.
    - 스크립트의 **`[Install]`** 섹션을  통해 시스템 시작 시 실행할 타켓을 명시할 수 있다.
- **`xinetd`** (eXtended InterNET) 방식
    - 시스템 시작 시 **`xinetd`** 를 **`standalone`** 방식으로 실행하고 사용자의 서비스 요청이 있을 때만 관련 데몬을 시작하여 서비스를 제공한다.
    - 사용자의 접속이 종료되면 데몬도 자동으로 종료된다.
    - 데몬이 필요할 때 로드되어 자원 효율이 좋지만 **`standalone`** 방식 대비 상대적으로 느리다.
    - 서비스의 요청이 빈번하지 않을 때 유리하다.
- **`systemd`**의 **온디맨드(on-demand)** 방식
    - **`systemd`** 는 **`xinetd`** 방식과 같은 데몬 실행 방식을 제공하며, 이를 **온디맨드** 방식이라고 한다.
    - **`systemd`** 에서 **온디맨드**로 데몬을 실행하기 위해 소켓 파일과 서비스 파일이 필요하다.
    

### 데몬 시작하기

- **`systemd`** 를 통해 데몬 시작하기
    - **`systemd`** 는 유닛 단위로 서비스를 관리한다.
        - 시스템에 로드된 모든 유닛을 확인하려면? → **`list-units`**
        - 서비스 타입의 유닛만을 확인하려면? → **`-t`** 옵션 사용
        - 로드되지 않은 유닛까지 확인하려면? → **`--all`** 옵션 사용
        - `$ systemctl list-units -t service`
    - 설치된 모든 유닛 파일을 보려면? → **`list-unit-files`**
        
        `$ systemctl list-unit-files -t service | grep httpd`
        
    - 데몬의 실행을 중지한다.
        
        `# systemctl stop httpd.service`
        
    - 데몬의 실행을 시작한다.
        
        `# systemctl start httpd.service`
        
    - 데몬을 재시작한다.
        
        `# systemctl restart httpd.service`
        
    - 데몬의 환경설정 파일을 갱신한다.
        
        `# systemctl reload httpd.service`
        
    - 데몬의 환경설정 파일을 갱신 후 재시작한다.
        
        `# systemctl reload-or-restart httpd.service`
        
    - 데몬의 상태를 확인한다.
        
        `# systemctl status httpd.service` 
        
- **`systemd`** 를 통해 원하는 타겟 실행 시 데몬 시작하기
    - 부팅 시 서비스가 시작할 수 있도록 서비스를 등록한다.
        
        `$ sudo systemctl enable httpd.service` 
        
        - 심볼릭 링크가 생성된다.
    - 서비스를 해제하면 생성되었던 심볼릭 링크도 함께 삭제된다.
        
        `$ sudo systemctl disable httpd.service`
        
    - 서비스의 시작 타겟을 변경하기 위해 service파일의 [Install] 섹션을 수정한다. 수정 후 **`systemctl`** 명령어로 **`enable`** 하면 변경된 설정으로 service를 등록한다.

### 데몬 실행 설정 도구

- **`systemctl`**
    - 원격지에 있는 서비스를 재시작한다.
        
        `# systemctl -H root@192.168.100.100 restart httpd.service`
        
    - 원격지에 있는 서비스의 상태를 확인한다.
        
        `# systemctl -H root@192.168.100.100 status httpd.service`
        
    - 서비스의 CPU 사용량 및 메모리 사용량을 제한한다. (**`-runtime`** 옵션을 사용하여 일시적 적용 가능)
        
        `# systemctl set-property httpd.service CPUShar=600 MemoryLimit=400M`
        
    - 현재 연결 대기 중인 소켓 목록을 확인한다.
        
        `$ systemctl list-sockets`
        
    - 지정한 유닛에 대한 의존 관계를 출력한다.
        
        `$ systemctl list-dependencies httpd.service`
        
    - 부팅하면서 시작 실패한 데몬을 확인한다.
        
        `$ systemctl --failed` 
        
- **`systemd-cgtop`**
    - cgroup(control group)에 속한 데몬에 대한 CPU 사용률, 메모리 사용량, I/O 입출력에 대한 실시간 정보를 제공한다.
- **`systemd-cgls`**
    - cgroup에 대한 정보를 계층적으로 출력한다.
    - 하나의 유닛에 여러 프로세스가 포함될 수 있음을 확인한다.
- **`systemd-analyze`**
    - 부팅 시 걸린 시간을 확인한다.
    - **`blame`** 옵션을 사용하여 각 서비스의 시작시간을 확인할 수 있다.
        
        `$ systemd-analyze blame`