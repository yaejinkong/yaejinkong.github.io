---
layout: post
title:  "[20231112] 데이터베이스 - 트랜잭션"
date:   2023-11-12 20:43:06 +0900
categories: 
            - Study
            - database
published: true
---

---
# 데이터베이스 '트랜잭션'

<br>
<br>

## 트랜잭션

- 트랜잭션은 데이터베이스에서 ACID 속성을 만족하는 일련의 작업이다. 
  - 원자성 (Atomicity) : 트랜잭션 내의 모든 작업은 하나의 불가분의 단위로 취급된다. 모든 작업이 실행되거나 전혀 실행되지 않는다.
  - 동시성 (Consistency) : 트랜잭션은 데이터베이스를 일관된 상태에서 다른 일관된 상태로 이동시킨다. 트랜잭션이 전후로 데이터베이스가 유효한 상태에 있도록 보장한다. 
  - 고립성 (Isolation) : 트랜잭션은 서로 독립적으로 실행되며, 다른 트랜잭션이 중간 상태를 볼 수 없게 한다.
  - 지속성 (Durability) : 트랜잭션이 커밋되면 그 변경사항은 영구적으로 유지된다.
- 데이터의 일관된 변경
- 데이터의 일관된 뷰
<br>

## 옛날 트랜잭션 시스템 디자이너들이 직면한 문제
- 트랜잭션이 동시에 실행될 때 일관성 없는 결과를 생성하는 문제.
- 동시에 실행되는 트랜잭션들로 인한 오류 또는 불일치한 분석의 문제 
- 변경사항이 영구적으로 되는 지에 대한 불확실성의 문제 - 변경 후에 항상 모든 버퍼 레코드를 기록해야 하는가? 입출력 비용을 줄일 수 있는 방법이 많지 않다.
<br>

## Interleaved (Concurrent) Operations

- Interleaved read-write operations이 CPU utilization을 높이고 I/O waiting time을 줄인다. -> 더 나은 TPS (초당 실행가능한 트랜잭션의 수) 
  - <span style="color:blue">CPU와 디스크의 작업을 교차로 수행하는 것이다.</span>
  - 직렬 스케줄을 고려한 경우 CPU가 일하는 시간이 5ms이고 디스크 입출력이 50ms 걸린다면 CPU 활용률을 계산할 수 있다.
  - TPS = 1000/100 = 9.09
  - 서로 간섭을 일으키지  않는다.
<center><img width="750" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/69ae52ba-f446-4ba8-866e-20182d3061db"></center>
<br>

## Two Interleaved Transactions with one Disk

- 두 개의 트랜잭션이 concurrent하게 싱글 디스크에 접근하고 있는 방식이다. 
- TPS = 1000/(5+45+50+5+45+50) = 5가 2개 = 10 TPS
- 디스크를 더 붙이면 성능이 늘어나고, TPS가 높아진다. 
- CPU가 100% 일할 때까지 디스크를 더 붙일 수 있다. 
<center><img width="750" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/6945eb2c-8506-4a5c-892f-4d55916c6bde">
</center>
<br>

## Two Interleaved Transactions with Two Disks

- TPS = 9.09 + 9.09 = 18.18
- CPU는 여전히 놀고 있다.
<center><img width="750" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/37a8f845-a02a-407f-a16d-f514ad7d40be">
</center>
<br>

## 11 Interleaved Transactions with 11 Disks

- 5 x 10 = 50. 총 11개를 갖다붙이면 CPU가 노는 시간이 없어진다. 
- TPS = 9.09 x 11 = 100
<center><img width="717" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/7746ba35-0a3e-4763-bb30-ac88da517035">
</center>
<br>

## 일관성 (Concurrency)는 통제되어야 한다.

- Concurrent access를 100% 보장해주면 response time이 빨라지지만, 여러 가지 문제가 생긴다. 따라서 통제(control)이 필요하다.
- Concurrency Control : Concurrency를 Control한다.
<br>

## 트랜잭션의 4가지 속성

- 원자성 (Atomicity) : 트랜잭션 내의 모든 작업은 하나의 불가분의 단위로 취급된다. 모든 작업이 실행되거나 전혀 실행되지 않는다. (All or nothing)
- 동시성 (Consistency) : 트랜잭션은 데이터베이스를 일관된 상태에서 다른 일관된 상태로 이동시킨다. 트랜잭션이 전후로 데이터베이스가 유효한 상태에 있도록 보장한다. 
- 고립성 (Isolation) : 두 트랜잭션이 서로 독립적으로 수행되는 것과 같은 결과를 얻어야 한다. 다른 트랜잭션이 중간 상태를 볼 수 없게 한다.
- 지속성 (Durability) : 성공적으로 COMMIT된 트랜잭션의 결과는 반드시 (crash가 발생한다 하더라도) DB에 반영되어야 한다.
- 원자성, 지속성 => logging / 동시성, 고립성 => concurrency control
<br>

## Read-only 트랜잭션의 경우

- Atomicity는 문제를 일으키지 않는다.
- Durability는 문제를 일으키지 않는다. 
- Isolation과 Consistency는 문제를 일으킬 수 있다. 
  - Uncommitted data (change)를 읽어서는 안된다.
  - <span style="color:blue">읽은 게 사실이 아닐 수 있다.</span>
<br>

## 트랜잭션 프로그래밍 예시

~~~java
create table acounts (
  acct int primary key,
  balance int default 0  
) ENGINE=INNODB;
insert into accounts values (1, 900);
insert into accounts values (2, 100);
~~~

- MySQL에서는 트랜잭션을 지원하기 위해 저장 엔진이 InnoDB 또는 BDB여야 한다. 
<br>

~~~java
import java.sql.*;
import javax.swing.JOptionPane;
import javax.swing.JPasswordField;
import java.io.*;

public class JDBCExample5 {
  public static void main (String args [])
  throws SQLException, IOException {
    try
    {
      // Connect to the database
      Class.forName ("com.mysql.cj.jdbc.Driver");
      String host = "000.000.ac.kr:3306/";
      String db = "0000000db";
      String password = getPassword();
      Connection con = DriverManager.getConnection("jdbc:mysql://" + host + db + "?useSSL=false", user, password);

      PreparedStatement update1 = con.prepareStatement("update accounts set balance = balance - ? where acct = ?");
      PreparedStatement update2 = con.prepareStatement("update accounts set balance = balance + ? where acct = ?");
      PreparedStatement stmt = con.prepareStatement("select balance from accounts where acct = ?");
      int from = Integer.parseInt(readEntry("Enter FROM account:"));
      int to = Integer.parseInt(readEntry("Enter To account:"));
      int amount = Integer.parseInt(readEntry("Enter AMOUNT to transfer:"));
      con.setAutoCommit(false);
      con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
      update1.setInt(1, amount);
      update1.setInt(2, from);
      update2.setInt(1, amount);
      update2.setInt(2, to);
      stmt.setInt(1, from);
      boolean success = false;
      ResultSet rset = null;

      try {
        // transaction starts here
        update1.executeUpdate();
        update2.executeUpdate();
        rset = stmt.executeQuery();
        rset.next();
        if(rset.getInt(1) >= 0)
          success = true;
        else 
          success = false;
      } catch (SQLException e) {
        System.out.println("Exception occured. Transaction will be roll backed");

        System.out.println("SQL State: " + e.getSQLState());
        System.out.println("SQL Error Message: " + e.getMessage());
      } finally {
          try {
            if (success) {
              con.commit();
              System.out.println("Transaction successfully committed!");
            } else {
                con.rollback();
                System.out.println("Transaction failed and rollbacked!");
            }
            if (rset != null) rset.close();
            if (stmt != null) stmt.close();
            if (update1 != null) update1.close();
            if (update != null) update2.close();
          } catch (SQLException sqle) {
            sqle.printStackTrace();
          }
      }

      // Close objects
      con.close();
      }
      // Close objects
      con.close();
    }
    catch (SQLException ex)
    {
      System.out.println("SQLException" + ex);
    }
    catch (Exception ex)
    {
      System.out.println("Exception:" + ex);
    }
}

private static String getPassword() {
  final String password, message = "Enter password";
  if(System.console() == null)
  {
    final JPasswordField pf = new JPasswordField();
    password = JOptionPane.showConfirmDialog(null, pf, message,
      JOptionPane.OK_CANCEL_OPTION,
      JOptionPane.QUESTION_MESSAGE ) == JOptionPane.OK_OPTION ?
        new String(pf.getPassword()) : "";
  }
  else
    password = new String(System.console().readPassword("%s> ", message
~~~
<br><br>

## No Locking - What happened?
<center><img width="717" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/7746ba35-0a3e-4763-bb30-ac88da517035"></center>
<br>

- inconsistent view of data : "A1 + A2 = $1000"는 계좌 이체 전이나 계좌이체 후나 항상 성립해야 하는 등식
- 예에서 T2는 inconsistent view를 보였다. (트랜잭션 전이나 트랜잭션 후에는 언제나 consistent 하다. 그와 다른 결과를 보았다면 inconsistent view를 본 것이다.)
- T1에서 되어질 일이 다른 트랜잭션에 의해 간섭받지 않고 이루어졌다면 (serial schedule) 이런 문제가 발생하는가?
- DBMS가 concurrent transaction의 serializability를 보장한다. 
<br>

## Serializability

- Serializability : Concurrent transaction에 대해 serial schedule이 존재하는가?
- <span style="background-color: #FFE6E6">Serial schedule이 존재하면 올바른 트랜잭션!</span>
- 두 개의 MySQL 창을 열어두고 (마치 두 개의 애플리케이션이 동시에 동작하는 것과 같다) DBMS가 Serializability를 보장하는 것을 확인해볼 것!
<br>



Exclusive Lock만 고려:

문서에서는 Exclusive Lock에 대해서 언급하고 있습니다. Exclusive Lock은 읽기와 쓰기를 모두 막는 가장 강력한 Lock 유형입니다. 이는 한 트랜잭션이 특정 row에 대한 Exclusive Lock을 획득하면, 다른 트랜잭션이 동시에 그 row에 접근할 수 없습니다.
트랜잭션 도중에 User Interaction이 있을 때의 질문:

트랜잭션이 진행 중에 사용자 상호작용이 발생하면 일반적으로 해당 트랜잭션은 일시 중지됩니다. 사용자와의 상호작용 후에 트랜잭션이 계속 진행되거나 롤백될 수 있습니다. 이러한 동작은 사용자와 데이터베이스 간의 일관성을 유지하기 위해 이루어집니다.

## Locking

- Locking은 트랜잭션의 고립을 보장하는데 사용된다. 
- isolation (고립)은 트랜잭션이 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행될 수 있도록 하는 것이다.
- 트랜잭션이 lock을 획득할 때까지 대기 : 트랜잭션이 특정 row에 접근할 때 해당 row에 대한 lock을 획득할 때까지 기다린다. 이로써 여러 트랜잭션이 동시에 동일한 데이터에 접근하지 못하도록 한다.
- 트랜잭션이 row에 접근 후 lock 설정 : 트랜잭션이 row에 접근하면 해당 row에 lock이 설정된다. 이 lock은 트랜잭션이 해당 row에 대한 변경을 수행하는 동안 다른 트랜잭션이 동시에 접근하지 못하게 한다.
- 획득한 lock은 commit 또는 rollback 시 해제된다. 
- Exclusive lock만 고려한다. 
  - 참고 : Shared (Read) Lock, Exclusive (Write) Lock
- Q: 트랜잭션 도중에 user interation이 있으면?
  - 트랜잭션 진행 중 user interaction (ex. 출력, 입력)이 발생하면 안된다.
<br>

## Locking - What happened?

- A1의 잔고를 $400.00 감소시키는 업데이트 트랜잭션이 실행되면 해당 row는 잠겨지며, 동시에 실행 중인 다른 트랜잭션인 T2는 해당 row에 대한 read and write를 할 수 없다.
- A2의 잔고를 $400.00 증가시켜 이체를 완료한다. 트랜잭션이 완료된 후에는 잠금이 해제된다.
- T2가 필요한 잠금을 얻을 수 있게 되고, A1의 잔고를 읽어와 합계에 더한다. 
- A2의 잔고를 읽어와 합계에 더한다. 
- 합계는 $1000.00이 되어 신용카드가 발급되는 등의 다른 작업을 수행한다. 
- 트랜잭션의 일관성을 유지하기 위해 이러한 locking이 필요하다. 

<center><img width="639" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/cd4466bd-43ae-40dd-a70d-cbb89eddf3aa"></center>
<br>

## Deadlock

- 두 개 이상의 트랜잭션이 동시에 풀릴 (해제될) 리소스를 기다리고 있는 상황이다. 
- deadlock : 두 개 이상의 트랜잭션이 각자의 lock을 획득하고 서로가 가진 lock을 기다리는 상태로, 트랜잭션들이 진행을 계속 하지 못하는 상황이다. 

<center><img width="652" alt="image" src="https://github.com/yaejinkong/yaejinkong.github.io/assets/127467781/12e33c36-3659-4299-84b1-a7aa67df5e0e"></center>
<br>

## 트랜잭션 History

- Atomic read
  - Ri(A) : 트랜잭션 Ti가 데이터 항목 A를 읽는 작업이다. 
  - Ri(A, val1) : 읽기 작업에서 읽은 값인 val1을 나타낸다.
  - SQL 문장으로 표현 : select val1 into :pgmval1 from T1 wherer uniqueid = A
- Atomic writes
  - Wj(B) : 트랜잭션 Ti가 데이터 항목 B를 쓰는 작업이다. 
  - Wj(B, val2) : 쓰기 작업에서 쓴 값인 val2를 나타낸다. 
  - SQL 문장으로 표현 : update T1 set val2 = pgmval2 where uniqueid = B
<br>

- R2(A) W2(A) R1(A) R1(B) R2(B) W2(B) C1 C2 - 위의 Transactional history의 예를 real world example(은행 계좌의 문제)로 바꿔보라. 
  - R2(A) W2(A) R1(A) R1(B) R2(B) W2(B) C1 C2 => A에서 B로 30 계좌 이체
<br>

## Serializabiltiy

- Interleaved schedule is serializable if there is an equivalent serial schedule
  - <span style="background-color: #fff5b1">Conflicting operations </span>: interleaved schedule에서 두 operations의 순서가 equivalent serial schedule에서 반드시 유지되어야 한다면 두 operations은 conflicting operations
  - H에서 conflicting operation의 순서는 <span style="background-color: #fff5b1">serial schedule S(H)에서 반드시 유지되어야 한다.</span>
  - R1(A) <<<sub>H</sub> W2(A) : history H에서 R1(A)가 W2(A)보다 먼저 발생한다. 
  - Equivalent serial history S(H)에서도 이 순서는 유지되어야 한다. 즉, R1(A) <<<sub>S(H)</sub> W2(A) 
  - T1 <<<sub>S(H)</sub> T2 : T1
